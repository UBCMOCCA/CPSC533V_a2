# CPSC 533V Assignment 2:  Building a Forward Dynamics Simulator
In this Assignment you will be developing a basic multi-link articulated rigid body simulator.  You will be using a maximal-coordinates, Newton-Euler formulation, with point-to-point constraints and Baumgarte stabilization. The end result will be a multi-link 3D pendulum. 

You will be using `python` and several python packages. Make sure that you have Python >= 3.7 installed, via `conda` or any other means. 

To install all dependencies, you may use the following command:

```
pip install -r requirements.txt
```

Run `python simulate.py`. If you are successful, you will see a GLUT window open with a single floating cuboid or 'link'. This has dimensions of 0.04m $\times$ 0.04m $\times$ 0.5m and a mass of 1kg.

The key code for the assignment can be found in `envs.py`, which contains the base class `BaseEnv`, as well as derived classes named `FallingLinkEnv`, `SpinningLinkEnv`, `SingleLinkPendulumEnv`, and `MultiLinkPendulumEnv`.  Inside each of these derived classes, you will be implementing the `step` method, which steps the simulation forward to the next display time step, and the `reset` method, which chooses how many links to create. 

The `step` method needs to: 

* Create the linear system of equations $Ax = b$ where $A$ is the Newton-Euler matrix and $b$ is the forces and torques involved in the Newton-Euler equations of motion.
* Solve for $x$ using a linear algebra solver, where $x$ gives the linear and angular accelerations of each link, as well as the constraint forces (if any).
* Integrate the motion forward in time, e.g., update the position, velocity, orientation, and angular velocity of each link.


The following scenarios enable you to progressively develop simulator, beginning with a simple particle simulator and ending with a pinned multilink 3D chain. Once done with the first environment, it will be useful for you to reuse the code, i.e., duplicate it, as the starting point for the next environment. Each individual environment thus becomes a check-point that can be tested.

### a. Falling Link

rubric={correctness: 3}

Modify the code in the `FallingLinkEnv` class so that the link moves according to  gravity (y is vertical), from the given initial velocity. There will be no angular component to the motion.

To run this environment use:
```
python simulate.py --environment fallinglink
```
### b. Spinning Link

rubric={correctness: 3}

Suppose a constant force $f = \begin{bmatrix}0 & 5 & 0\end{bmatrix}^T$ (in the world frame) is applied to the one end of the link, as given by $r = \begin{bmatrix} 0 & 0.25 & 0\end{bmatrix}^T$ (in local coordinate system with respect to the cube's center of mass); see ```link.get_r()```.  Set the initial velocity to zero.

Modify the code in the `SpinningLinkEnv` class so that the link experiences gravity and the force and torque generated by applying $f$.

To run this environment use:
```
python simulate.py --environment spinninglink
```
### c. Single Link Pendulum

rubric={correctness: 3}

Modify the code in the `SingleLinkPendulumEnv` class to create a pendulum that has one end pinned at a fixed point, given by ```self.anchor``` in the world frame. First implement and test this without Baumgarte stabilization and without any damping of the movement.  Next, add some angular damping to dissipate the energy over time.  Lastly, add Baumgarte stabilization.

To run this environment use:
```
python simulate.py --environment singlelinkpendulum
```
### e. Two-Link Pendulum

rubric={correctness: 3}

Extend your previous solution to a two-link pendulum. Add energy dissipation and Baumgarte stabilization. Optionally, extend it to handle any number of links. 

To run this environment use:
```
python simulate.py --environment multilinkpendulum
```
### f. Ground contact (optional)

Extend your solution from part (e) to add ground contact forces at the link end-points, based on a simple spring-and-damper penalty-method.

